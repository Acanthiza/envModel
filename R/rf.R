
#' Run a basic random forest, saving only the confusion matrix.
#'
#' @param df Dataframe with clusters, context and environmental columns.
#' @param clust_col Character. Name of column with cluster membership.
#' @param env_cols Character. Name of columns with environmental data.
#' @param trees Numeric. How many trees in the forest?
#' @param out_file Character. Path for saving the confusion matrix.
#'
#' @return
#' @export
#'
#' @examples
  make_rf_conf <- function(df
                           , clust_col = "cluster"
                           , env_cols
                           , trees = 999
                           , out_file
                           ) {

    x_df <- df[,which(names(df) %in% env_cols)]
    y_vec <- df %>% dplyr::pull(!!ensym(clust_col))

    # Assumes envData exists and is ready to go
    rf <- randomForest::randomForest(x = x_df
                                 , y = y_vec
                                 , ntree = trees
                                 )

    conf <- caret::confusionMatrix(rf$predicted,df$cluster)

    rio::export(conf, out_file)

  }


  make_rf_quick <- function(x_df
                             , y_vec
                             , trees = 499
                             , cl_obj = NULL
                             , use_mtry
                             ) {

    rf_cores <- if(isTRUE(is.null(cl_obj))) 1 else length(cl_obj)

    foreach::`%dopar%`(ntree = rep(ceiling(trees/rf_cores), rf_cores)
            , .combine = randomForest::combine
            , .packages = c("randomForest")
            ) %dopar%
      randomForest::randomForest(x = x_df
                                 , y = y_vec
                                 , importance = TRUE
                                 , mtry = use_mtry
                                 , ntree = ntree
                                 )

  }

#' Title
#'
#' @param env_df Dataframe with `clust_col`, `site_col` and columns `env_names`
#' @param clust_col Character. Name of the columns with clusters.
#' @param context Character. Name of the columns defining the context.
#' @param env_names Character. Name of the environmental variables (e.g.
#' `names(stack_list)`).
#' @param trees_start Number of trees in first random forest run.
#' @param trees_add Number of trees to add in each subsequent run.
#' @param rf_cores Number of cores to use for parallel processing.
#' @param use_mtry `mtry` value for `randomForest` call. If `NULL` it will be
#' generated by a (lengthy) call to `caret::train` with a tune grid of
#' `.mtry = 1:floor(sqrt(length(env_names))`
#' @param out_file Optional name of file to save results.
#'
#' @return
#' @export
#'
#' @examples
  make_rf_good <- function(env_df
                           , clust_col = "cluster"
                           , context = "cell"
                           , env_names
                           , trees_start = 499
                           , trees_add = 249
                           , rf_cores = 1
                           , use_mtry = NULL
                           , out_file = NULL
                           ) {

    if(isTRUE(!is.null(out_file))) {

      out_file <- gsub("\\.*$","",out_file)
      out_file <- paste0(out_file,".rds")

    }

    x <- env_df[,which(names(env_df) %in% env_names)]
    y <- env_df[clust_col][[1]]

    rf_good <- list()

    # setup parallel cluster
    cl <- parallel::makePSOCKcluster(rf_cores)
    doParallel::registerDoParallel(cl)

    if(isTRUE(is.null(use_mtry))) {

      # Training control for caret implementation of machine learning methods
      ctrl <- caret::trainControl(method = "cv"
                                  , savePredictions = FALSE
                                  , verboseIter = FALSE
                                  , allowParallel = TRUE
                                  )

      # Tuning grid
      c_tune_grid <- expand.grid(.mtry = 1:floor(sqrt(length(env_names))))

      cl <- parallel::makePSOCKcluster(rf_cores)
      doParallel::registerDoParallel(cl)

      rf_good$rf_mtry <- caret::train(x
                                      , y
                                      , method = "rf"
                                      , trControl = ctrl
                                      , tuneGrid = c_tune_grid
                                      , metric = "Kappa"
                                      , trace = FALSE
                                      )

      rf_good$mtry <- rf_good$rf_mtry %>%
        `[[` ("finalModel") %>%
        `[[` ("mtry")

      } else rf_good$mtry <- use_mtry


    rf_good$rf_res <-
      tibble(run = 1
             , trees = trees_start
             , start = Sys.time()
             ) %>%
      dplyr::mutate(rf = list(make_rf_simple(x
                                             , y
                                             , trees = trees_start
                                             , cl_obj = cl
                                             , use_mtry = rf_good$mtry
                                             )
                              )
                    , seconds = Sys.time() - start
                    , delta_prev = 0.5
                    , kappa_prev = map_dbl(rf
                                           , ~caret::confusionMatrix(.$predicted
                                                                  , .$y
                                                                  )$overall[["Kappa"]]
                                           )
                    , ntree = map_dbl(rf,"ntree")
                    )

    while(
      as.logical(
        (rf_good$rf_res$kappa_prev[[nrow(rf_good$rf_res)]] <= 0.995) *
        (rf_good$rf_res$delta_prev[[nrow(rf_good$rf_res)]] <= 0.995) *
        (rf_good$rf_res$trees[[nrow(rf_good$rf_res)]] < 9999)
      )
    ) {

      prev_rf <- rf_good$rf_res$rf[nrow(rf_good$rf_res)][[1]]

      start <- Sys.time()

      next_rf <- make_rf_simple(x
                                , y
                                , trees = trees_add
                                , cl_obj = cl
                                , use_mtry = rf_good$mtry
                                )

      rf_run_time <- Sys.time() - start

      new_rf <- randomForest::combine(prev_rf,next_rf)

      kappa <- caret::confusionMatrix(new_rf$predicted
                                      , new_rf$y
                                      )$overall[["Kappa"]]

      delta_prev <- sum(init_rf$predicted == new_rf$predicted)/length(y)

      kappa_prev <- caret::confusionMatrix(init_rf$predicted
                                           , new_rf$predicted
                                           )$overall[["Kappa"]]

      rf_good$rf_res <- rf_good$rf_res %>%
        dplyr::bind_rows(tibble(
          run = max(rf_good$rf_res$run) + 1
          , trees = max(rf_good$rf_res$trees) + next_rf$ntree
          , start = start
          , rf = list(new_rf)
          , seconds = rf_run_time
          , delta_prev = delta_prev
          , kappa_prev = kappa_prev
          , ntree = new_rf$ntree
          )
          )

      cat(
        paste0("ntree: ", rf_good$rf_res$rf[[nrow(rf_good$rf_res)]]$ntree
               , "\n kappa: ",round(kappa,4)
               , "\n changed predictions: ",paste0(round(100-100*rf_good$rf_res$delta_prev[nrow(rf_good$rf_res)],3),"%")
               , "\n kappa based on confusion with last run: ", round(rf_good$rf_res$kappa_prev[[nrow(rf_good$rf_res)]],4)
               , "\n time: ",round(rf_good$rf_res$seconds[[nrow(rf_good$rf_res)]],2)," seconds\n\n"
        )
      )

    }

    parallel::stopCluster(cl)
    rm(cl)

    if(!isTRUE(is.null(out_file))) rio::export(rfgood,out_file)

    return(rfgood)

  }



